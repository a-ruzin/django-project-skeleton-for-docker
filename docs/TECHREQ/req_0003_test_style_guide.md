# REQ: 0003

## Стайлгайд написания тестов
Автор: Чегодаев Илья

## Хранение
Ниже представлено примерное дерево хранения файлов с тестами.
```
tests
├── conftest.py
├── factories.py
├── test_module_one
│   ├── conftest.py
│   ├── factories.py
│   ├── test_function_one.py
│   └── test_function_two.py
└── test_module_two
    ├── conftest.py
    ├── factories.py
    └── test_function_three.py
```
Переиспользуемые в разных модулях фикстуры и фабрики (например `UserFactory`) помещаются на верхний уровень (в папку `tests`).
Всё, что относится к конкретному модулю - помещается в папку с тестами этого модуля.
_Пример_: фикстуры для модуля `module_one` хранятся по пути `/test_module_one/conftest.py`.

## Именование
1. Функции юнит-тестов именуются по имени тестируемой функции с уточнением результата и\или особенностей работы теста: по шаблону test__<function_name>__<case_name>).
_Пример_: если функция называется `get_extended_warranty`, то тест на ошибку подсчёта суммы в этой функции будет называться `test__get_extended_warranty__sum_error`.
2. Функции интеграционных тестов именуются почти так же, как и юнит-тесты, только вместо имени функции исопльзуется наименование тестируемого действия.
  _Пример_: если тестируется, к примеру, поведение системы при отсылке запроса, который создаёт сущность успешно, тест будет называться `test__create_entitiy__success`.
3. Фабрики для объектов пишутся в CamelCase, с использованием полного названия модели плюс `Factory`.
_Пример_: для модели `BlogArticle` фабрика будет называться `BlogArticleFactory`.
4. Фикстуры, которые создаются _от_ фабрик, именуем по принципу `{model_name}_factory_{case_name}`.
_Пример_: существует отдельный `class UserFactory()`, который зарегистрирован и вызывается в тестах как фикстура вида `user_factory`. В отдельных случаях нужно всегда создавать пользоватея, у которого задан определённый параметр в одно и то же значение (например администратор). Для этого создаём фикстуры с названиями `user_factory_admin`, или `user_factory_moderator` и так далее.

## Паттерн ААА
Для повышения читабельности рекомендуется использовать паттерн ААА - Arrange, Act, Assert, в котором любой тест делится на три обособленные секции, отделённые одной пустой строкой.
- **Arrange** - собираем все данные для теста, объявляем переменные и создаём объекты из фабрик;
- **Act** - выполняем действие, нуждающееся в проверке. Обычно эта секция состоит из наименьшего количества строчек;
- **Assert** - проверяем результаты теста. Именно в этой секции написаны все инструкции `assert`. Если нужно проверить какие-то промежуточные результаты, совершить какие-то действия и проверить ещё раз, то промежуточные результаты можно записать в отдельную переменную, чтобы все `assert`'ы были в одном месте.

_Пример_:
```python
@pytest.fixture(...some parametrization...)
def test__get_sum__without_arguments(...some fixtures...):
    # Arrange
    argument_one = None
    argument_two = 'zero'

    # Act
    sum_one = get_sum(argument_one)
    sum_two = get_sum(argument_two)

    # Assert
    assert sum_one == Decimal(0.0)
    assert sum_two == Decimal(0.0)
```

## Параметризация
Для того, чтобы запустить один и тот же тест с разными входными и выходными данными, можно использовать декоратор `@pytest.parametrize`.
_Пример_:
```python
@pytest.parametrize(
    ('url', 'status'),
    [
        ('example.com', '200'),
        ('exmapl.com', '404',),
        ('mytestsite.com', '503'),
    ],
):
def test__get_page__status(url, status):
    result_status = get_page(url)

    assert status == result_status
```
В данном примере тест запустится 3 раза, каждый раз передавая внутрь теста соответствующие аргументы `url` и `status`. В эмуляторе терминала (в режиме verbose) данные тесты будут именоваться цифрами. Для наибольшей читабельности все отдельные случаи в `parametrize` можно именовать с помощью аргумента `ids` (подробнее в документации Pytest).

## Пропуск тестов
Мы можем целенаправленно пропустить тест, если в данный момент он не нужен или не может быть написан с помощью декоратора `@pytes.mark.skip`, при этом желательно указывать причину в аргументе `reason`.
Если тест не пройдёт (должен упасть с каким-либо исключением) - помечаем его маркером `@pytest.mark.xfail`. Такие тест будут считаться пройденными библиотекой `pytest`, если в результате его выполнения произошла ошибка, и наоборот.
_Пример_:
```python
@pytes.mark.skip(reason='Outdated code')
def test__windows_xp():
    # Этот тест выполняться не будет

@pytest.mark.xfail
def test__null_pointer_exception():
    # Этот тест будет принят как выполненный несмотря на исключение
    result = 1 / 0
    assert result == '+INF'
```

## Описание типов
**НЕ НАДО**. Обычно в коде, относящемуся к тестам, не используют тайп хинты - они существенно "замусоривают" тесты из-за необходимости использовать протоколы или любой другой источник "утиной типизации" (TypeAlias и так далее), что, к тому же, тратит сильно много времени с очень небольшой пользой. Кроме того, желательно вовсе отключить проверку типов с помощью `mypy` во всём пространстве, связанном с тестами.

## Создание фабрик
Мы используем библиотеку `factory-boy` для быстрой генерации тестовых объектов из готовых Django-моделей. `factory.Faker` позволяет быстро генерировать тестовые данные для всех случаев жизни (подробности в документации Faker). Кроме того, эта библиотека позволяет назначить случайны вариант из набора данных (например, Django Choices), случайную дату или число из выбранного диапазона и так далее. Фабрику следует именовать как класс, используя SnakeCase - MyModelFactory, где MyModel - название класса модели.
_Пример_:
```python
import factory
from django.db import models
class MyModel(models.Model):
    name = models.CharField('Имя человека', blank=False)
    age = models.IntegerField('Возраст человека', blank=False)

class MyModelFactory(factory.django.DjangoModelFactory):
    class Meta:
        models = MyModel

    name = factory.Faker('first_name')
    age = factory.fuzzy.FuzzyInteger(18, 99)
```
Обратите внимание на то, что аргумент `name` объявлен с помощью т.н. провайдера `first_name` - в документации Faker можно просмотреть список всех провайдеров (также можно написать свой). Возраст же задан с помощью fuzzy-атрибута - случайное число в диапазоне от 18 до 99.

## Регистрация фабрик
После создания фабрик их нужно зарегистрировать. В таком случае их можно будет использовать в любых тестах без импортов.
Регистрация фабрик осуществляется с помощью пакета `pytest_factoryboy`:
```
from .factories import DocumentFactory
from pytest_factoryboy import register

# ...

register(DocumentFactory)
```
Регистрацию фабрик желательно помещать в конец соответствующего файла `conftest.py` - таким образом все настройки, необходимые для тестов (фикстуры и прочее) будут в одном файле, а также регистрируемые фабрики не будут лишний раз мешать просматривать остальное.

## Использование фабрик
### Подключение в тест
После регистрации фабрику можно использовать как фикстуру, без необходимости импортирования. Наименование фабрики пишется в CamelCase как принятый стандарт именования любого класса в Python, однако "магия" `pytest` позволяет импортировать зарегистрированную фабрику, указав её имя в snake_case.
_Пример_:
```python
class CommentFactory():
    # example factory in factories.py file
    ...

def test__get_comment_text__success(comment_factory):
    comment_text = 'Sample comment text'
    sample_comment = comment_factory(text=comment_text)

    result_comment_text = sample_comment.get_comment_text()

    assert result_comment_text == comment_text
```
### Создание объектов
После импорта в тест-функцию фабрику можно использовать для создания объектов. Одновременно можно создавать несколько объектов с помощью `.create_batch` - в параметре `size` необходимо указывать количество создаваемых объектов. Кроме того, фабрики позволяют создавать объекты с заранее известными значениями свойств, даже если они генерируются в фабрике. Для этого нужно передать словарь вида `{'свойство': 'значение'}` при создании объекта из фабрики (это также можно делать при множественном создании объектов, тогда этот словарь передаётся в `create_batch`).
_Пример_:
```python
# UserFactory - фабрика, зарегистрированная в conftest.py

def test__get_user__different__names(user_factory):
    users_count = 11
    # Создание 10 пользователей в базе
    user_factory.create_batch(size=users_count)
    # Создание одного пользователя с другим именем
    diff_user = user_factory(name='John Doe')

    expected_users_count = get_users()

    assert users_count == expected_users_count
```

## Фикстуры как фабрики
При переиспользовании данных можно создавать фикстуры, которые возвращают фабрики. Суть в том, что фикстура вместо непосредственно данных возвращает функцию, которая генерирует данные, при этом имея возможность принимать параметры для изменения этих данных. _Пример_:
```python
@pytest.fixture
def user_data():
    def _user_data(**kwargs):
        data = {
            'name': 'John Doe'.
            'age': '15',
        }
        data.update(kwargs)
        return data
    return _user_data

def test__user(user_data):
    user1 = user_data()
    user2 = user_data(name='Terry Crews')

    assert user1.name == 'John Doe'
    assert user2.name == 'Terry Crews'
```
Такие фикстуры также могут выполнять финализацию данных при необходимости. Для этого вместо ключевого слова `return` при возврате внутренней функции нужно использовать конструкцию `yield`, а послее неё можно выполнить любые действия по дальнейшей обработке этих данных. Эта обработка будет выполнена после завершения теста. _Пример_:
```python
@pytest.fixture
def new_user():
    def _new_user(**kwargs):
        data = {
            'name': 'John Doe'.
            'age': '15',
        }
        data.update(kwargs)
        user = User(*data).save()
        return data

    yield _user_data

    user.delete()

```
